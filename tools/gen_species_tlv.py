#!/usr/bin/env python3
import argparse
import json
import pathlib
import struct
import sys
from typing import Dict, Any

# TLV type identifiers shared with firmware
TLV_PROFILE = 0x01
TLV_KEY = 0x02
TLV_LABELS = 0x03
TLV_LABEL_ENTRY = 0x04
TLV_LABEL_LANG = 0x05
TLV_LABEL_TEXT = 0x06
TLV_HABITAT = 0x07
TLV_METADATA = 0x08
TLV_METADATA_UV_PEAK = 0x09
TLV_METADATA_UV_CATEGORY = 0x0A
TLV_METADATA_SEASON = 0x0B
TLV_SCHEDULE = 0x0C
TLV_DAY_START = 0x0D
TLV_NIGHT_START = 0x0E
TLV_DAY_TEMP = 0x0F
TLV_DAY_HUMIDITY = 0x10
TLV_DAY_TEMP_HYST = 0x11
TLV_DAY_HUMID_HYST = 0x12
TLV_DAY_UVI_MAX = 0x13
TLV_NIGHT_TEMP = 0x14
TLV_NIGHT_HUMIDITY = 0x15
TLV_NIGHT_TEMP_HYST = 0x16
TLV_NIGHT_HUMID_HYST = 0x17
TLV_NIGHT_UVI_MAX = 0x18

HEADER_TEMPLATE = """// Auto-generated by tools/gen_species_tlv.py -- DO NOT EDIT MANUALLY
#pragma once
#include <stddef.h>
#include <stdint.h>

#define SPECIES_TLV_PROFILE        0x01
#define SPECIES_TLV_KEY            0x02
#define SPECIES_TLV_LABELS         0x03
#define SPECIES_TLV_LABEL_ENTRY    0x04
#define SPECIES_TLV_LABEL_LANG     0x05
#define SPECIES_TLV_LABEL_TEXT     0x06
#define SPECIES_TLV_HABITAT        0x07
#define SPECIES_TLV_METADATA       0x08
#define SPECIES_TLV_METADATA_UV_PEAK   0x09
#define SPECIES_TLV_METADATA_UV_CATEGORY 0x0A
#define SPECIES_TLV_METADATA_SEASON 0x0B
#define SPECIES_TLV_SCHEDULE       0x0C
#define SPECIES_TLV_DAY_START      0x0D
#define SPECIES_TLV_NIGHT_START    0x0E
#define SPECIES_TLV_DAY_TEMP       0x0F
#define SPECIES_TLV_DAY_HUMIDITY   0x10
#define SPECIES_TLV_DAY_TEMP_HYST  0x11
#define SPECIES_TLV_DAY_HUMID_HYST 0x12
#define SPECIES_TLV_DAY_UVI_MAX    0x13
#define SPECIES_TLV_NIGHT_TEMP     0x14
#define SPECIES_TLV_NIGHT_HUMIDITY 0x15
#define SPECIES_TLV_NIGHT_TEMP_HYST 0x16
#define SPECIES_TLV_NIGHT_HUMID_HYST 0x17
#define SPECIES_TLV_NIGHT_UVI_MAX  0x18

static const uint8_t species_builtin_tlv[] = {{
{array_data}
}};

static const size_t species_builtin_tlv_len = sizeof(species_builtin_tlv);
"""


def tlv(type_id: int, payload: bytes) -> bytes:
    if len(payload) > 0xFFFF:
        raise ValueError(f"TLV payload too large for type {type_id}")
    return bytes([type_id]) + len(payload).to_bytes(2, "big") + payload


def encode_schedule(schedule: Dict[str, Any]) -> bytes:
    day = schedule["day"]
    night = schedule["night"]
    parts = []
    parts.append(tlv(TLV_DAY_START, struct.pack(">H", int(schedule["day_start_minute"])) ))
    parts.append(tlv(TLV_NIGHT_START, struct.pack(">H", int(schedule["night_start_minute"])) ))
    parts.append(tlv(TLV_DAY_TEMP, struct.pack(">f", float(day["temp_c"]))))
    parts.append(tlv(TLV_DAY_HUMIDITY, struct.pack(">f", float(day["humidity_pct"]))))
    parts.append(tlv(TLV_DAY_TEMP_HYST, struct.pack(">f", float(day["temp_hysteresis_c"]))))
    parts.append(tlv(TLV_DAY_HUMID_HYST, struct.pack(">f", float(day["humidity_hysteresis_pct"]))))
    parts.append(tlv(TLV_DAY_UVI_MAX, struct.pack(">f", float(schedule["day_uvi_max"]))))
    parts.append(tlv(TLV_NIGHT_TEMP, struct.pack(">f", float(night["temp_c"]))))
    parts.append(tlv(TLV_NIGHT_HUMIDITY, struct.pack(">f", float(night["humidity_pct"]))))
    parts.append(tlv(TLV_NIGHT_TEMP_HYST, struct.pack(">f", float(night["temp_hysteresis_c"]))))
    parts.append(tlv(TLV_NIGHT_HUMID_HYST, struct.pack(">f", float(night["humidity_hysteresis_pct"]))))
    parts.append(tlv(TLV_NIGHT_UVI_MAX, struct.pack(">f", float(schedule["night_uvi_max"]))))
    return tlv(TLV_SCHEDULE, b"".join(parts))


def encode_metadata(metadata: Dict[str, Any], habitat: str) -> bytes:
    parts = []
    if habitat:
        parts.append(tlv(TLV_HABITAT, habitat.encode("utf-8")))
    if metadata:
        if "uv_index_peak" in metadata:
            parts.append(tlv(TLV_METADATA_UV_PEAK, struct.pack(">f", float(metadata["uv_index_peak"]))))
        if "uv_index_category" in metadata and metadata["uv_index_category"]:
            parts.append(tlv(TLV_METADATA_UV_CATEGORY, str(metadata["uv_index_category"]).encode("utf-8")))
        if "season_cycle" in metadata and metadata["season_cycle"]:
            parts.append(tlv(TLV_METADATA_SEASON, str(metadata["season_cycle"]).encode("utf-8")))
    if not parts:
        return b""
    return tlv(TLV_METADATA, b"".join(parts))


def encode_labels(labels: Dict[str, str]) -> bytes:
    entries = []
    for lang in sorted(labels.keys()):
        text = labels[lang]
        payload = tlv(TLV_LABEL_LANG, lang.encode("utf-8")) + tlv(TLV_LABEL_TEXT, text.encode("utf-8"))
        entries.append(tlv(TLV_LABEL_ENTRY, payload))
    return tlv(TLV_LABELS, b"".join(entries))


def build_tlv_blob(profiles: Any) -> bytes:
    blob = bytearray()
    for profile in profiles:
        payload = bytearray()
        payload += tlv(TLV_KEY, profile["key"].encode("utf-8"))
        payload += encode_labels(profile["labels"])
        metadata = profile.get("metadata", {})
        habitat = profile.get("habitat", "")
        meta_payload = encode_metadata(metadata, habitat)
        if meta_payload:
            payload += meta_payload
        else:
            if habitat:
                payload += tlv(TLV_HABITAT, habitat.encode("utf-8"))
        payload += encode_schedule(profile["schedule"])
        blob += tlv(TLV_PROFILE, bytes(payload))
    return bytes(blob)


def format_bytes(data: bytes) -> str:
    lines = []
    for i in range(0, len(data), 12):
        chunk = data[i:i + 12]
        chunk_str = ", ".join(f"0x{b:02X}" for b in chunk)
        if i + 12 < len(data):
            lines.append(f"    {chunk_str},")
        else:
            lines.append(f"    {chunk_str}")
    return "\n".join(lines)


def main() -> int:
    parser = argparse.ArgumentParser(description="Generate TLV blob for builtin species profiles")
    parser.add_argument("--input", default="firmware/controller/main/species_builtin.json", help="Input JSON file")
    parser.add_argument("--output", default="firmware/controller/main/species_builtin_tlv.h", help="Output header path")
    args = parser.parse_args()

    input_path = pathlib.Path(args.input)
    output_path = pathlib.Path(args.output)

    if not input_path.exists():
        print(f"Input file {input_path} not found", file=sys.stderr)
        return 1

    with input_path.open("r", encoding="utf-8") as f:
        profiles = json.load(f)

    blob = build_tlv_blob(profiles)
    array_data = format_bytes(blob)
    header_text = HEADER_TEMPLATE.format(array_data=array_data)

    output_path.parent.mkdir(parents=True, exist_ok=True)
    with output_path.open("w", encoding="utf-8") as f:
        f.write(header_text)
    return 0


if __name__ == "__main__":
    sys.exit(main())
